<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML UI Editor with Design Controls</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the editor canvas */
        #editor-canvas {
            min-height: 500px;
            position: relative;
            background-image: linear-gradient(to right, #e5e7eb 1px, transparent 1px), linear-gradient(to bottom, #e5e7eb 1px, transparent 1px);
            background-size: 20px 20px;
            overflow: hidden;
            user-select: none;
            touch-action: none; /* Crucial for preventing default scroll on touch */
        }
        
        /* Center Guide Lines */
        #editor-canvas::before, #editor-canvas::after {
            content: '';
            position: absolute;
            background: rgba(255, 0, 0, 0.3); /* Subtle red center line */
            z-index: 500;
        }

        #editor-canvas::before { /* Vertical line */
            width: 1px;
            height: 100%;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
        }
        
        #editor-canvas::after { /* Horizontal line */
            width: 100%;
            height: 1px;
            top: 50%;
            left: 0;
            transform: translateY(-50%);
        }

        /* Styling for the interactive element (the button wrapper) */
        .ui-element-wrapper {
            position: absolute;
            cursor: grab;
            border: 2px solid transparent;
            box-sizing: border-box;
            transition: box-shadow 0.1s;
        }

        /* State for Responsive Centering (New) */
        .ui-element-wrapper[data-centered="true"] {
            left: 50% !important;
            top: 50% !important;
            transform: translate(-50%, -50%);
            cursor: default; /* Cannot drag when centered */
            outline: 2px dashed #10b981; /* Green outline to show centered state */
            outline-offset: 2px;
        }

        .ui-element-wrapper.active {
            border-color: #3b82f6; /* Blue border when active */
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
            z-index: 1000 !important; /* Ensure active element is always visible during editing */
        }

        /* Styling for the resize handles */
        .resize-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #3b82f6;
            border: 1px solid #ffffff;
            border-radius: 50%;
            z-index: 1001; 
            box-sizing: border-box;
            touch-action: none; /* Prevent scroll on handle interaction */
        }

        /* Specific cursor styles for handles */
        .handle-tr { top: -5px; right: -5px; cursor: nesw-resize; }
        .handle-br { bottom: -5px; right: -5px; cursor: nwse-resize; }
        .handle-bl { bottom: -5px; left: -5px; cursor: swne-resize; }
        .handle-tl { top: -5px; left: -5px; cursor: nwse-resize; }

        .ui-button {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: default; 
            transition: background-color 0.3s ease;
        }
    </style>
</head>
<body class="bg-gray-50 font-sans p-4 md:p-8">

    <h1 class="text-3xl font-extrabold text-gray-800 mb-6 border-b pb-2">Visual HTML Button Editor</h1>

    <div class="flex flex-col lg:flex-row gap-6">

        <div class="lg:w-1/4 space-y-6">

            <div class="bg-white p-4 rounded-xl shadow-lg">
                <h2 class="text-xl font-semibold mb-3 text-gray-700">Toolbox</h2>
                <div class="space-y-2">
                    <button id="add-button" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition duration-150 shadow-md">
                        + Add Button
                    </button>
                    <button id="add-ui" class="w-full bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg transition duration-150 shadow-md">
                        + Add UI
                    </button>
                    <button id="center-element-toggle" class="w-full bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-lg transition duration-150 shadow-md disabled:opacity-50" disabled>
                        Enable Responsive Centering
                    </button>
                </div>
            </div>
            
            <div id="properties-panel" class="bg-white p-4 rounded-xl shadow-lg transition-opacity duration-300">
                <h2 class="text-xl font-semibold mb-3 text-gray-700">Element Properties</h2>
                <div id="no-selection-message" class="text-gray-500 italic">
                    Select an element on the canvas to edit its properties.
                </div>

                <div id="properties-controls" class="space-y-4 hidden">
                    <div>
                        <label for="prop-text" class="block text-sm font-medium text-gray-700">Text Content</label>
                        <input type="text" id="prop-text" class="mt-1 w-full p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500">
                    </div>

                    <div class="flex gap-4">
                        <div class="w-1/2">
                            <label for="prop-width" class="block text-sm font-medium text-gray-700">Width (px)</label>
                            <input type="number" id="prop-width" min="50" class="mt-1 w-full p-2 border border-gray-300 rounded-lg">
                        </div>
                        <div class="w-1/2">
                            <label for="prop-height" class="block text-sm font-medium text-gray-700">Height (px)</label>
                            <input type="number" id="prop-height" min="30" class="mt-1 w-full p-2 border border-gray-300 rounded-lg">
                        </div>
                    </div>

                    <div class="flex gap-4">
                        <div class="w-1/2">
                            <label for="prop-bg-color" class="block text-sm font-medium text-gray-700">Background Color</label>
                            <input type="color" id="prop-bg-color" class="mt-1 w-full h-10 border border-gray-300 rounded-lg">
                        </div>
                        <div class="w-1/2">
                            <label for="prop-text-color" class="block text-sm font-medium text-gray-700">Text Color</label>
                            <input type="color" id="prop-text-color" class="mt-1 w-full h-10 border border-gray-300 rounded-lg">
                        </div>
                    </div>

                    <div>
                        <label for="prop-font-size" class="block text-sm font-medium text-gray-700">Font Size (px)</label>
                        <input type="number" id="prop-font-size" min="8" max="48" class="mt-1 w-full p-2 border border-gray-300 rounded-lg">
                    </div>
                </div>
            </div>

            <div class="bg-white p-4 rounded-xl shadow-lg">
                <h2 class="text-xl font-semibold mb-3 text-gray-700">Layers (Z-Index)</h2>
                <ul id="layer-panel" class="space-y-2 text-sm">
                    <li class="p-2 text-gray-500 italic">No elements yet.</li>
                </ul>
            </div>

            <div class="bg-white p-4 rounded-xl shadow-lg">
                <h2 class="text-xl font-semibold mb-3 text-gray-700">HTML Output</h2>
                <textarea id="html-output" rows="8" class="w-full p-2 border border-gray-300 rounded-lg text-xs font-mono bg-gray-50" readonly></textarea>
                <button id="copy-html-button" class="mt-2 w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition duration-150 shadow-md">
                    Copy HTML to Clipboard
                </button>
                <p id="copy-message" class="text-xs text-green-600 mt-2 hidden">Copied!</p>
            </div>
        </div>

        <div class="lg:w-3/4 bg-white p-2 rounded-xl shadow-lg border-4 border-dashed border-gray-200">
            <h2 class="text-xl font-semibold p-2 mb-2 text-gray-700">Design Canvas</h2>
            <div id="editor-canvas" class="rounded-lg shadow-inner bg-white">
                </div>
        </div>

    </div>

    <script>
        // Global state and constants 
        const canvas = document.getElementById('editor-canvas');
        const layerPanel = document.getElementById('layer-panel');

        let addButton, addUI, centerElementToggle, htmlOutput, copyHtmlButton, copyMessage; 
        let propertiesPanel, noSelectionMessage, propertiesControls;
        let propText, propWidth, propHeight, propBgColor, propTextColor, propFontSize;
        
        // Drag/Resize variables
        let activeElement = null; 
        let elementCounter = 0;
        let isDragging = false;
        let isResizing = false;
        let activeHandle = null;
        let startX, startY, startWidth, startHeight, startLeft, startTop;
        let draggedLi = null; 

        // --- Utility Functions ---

        /**
         * Converts RGB string to hex color (e.g., rgb(255, 255, 255) -> #ffffff)
         * Used for displaying color in the hex input field.
         */
        function rgbToHex(rgb) {
            if (!rgb || rgb.startsWith('#')) return rgb || '#ffffff';

            const match = rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
            if (!match) return '#ffffff'; 

            const toHex = (c) => {
                const hex = parseInt(c).toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            };
            return `#${toHex(match[1])}${toHex(match[2])}${toHex(match[3])}`;
        }

        // --- Core Logic ---

        /**
         * Generates the HTML markup for all elements on the canvas, wrapped in a runnable HTML document.
         */
        function updateHtmlOutput() {
            const elements = Array.from(canvas.querySelectorAll('.ui-element-wrapper'));
            let innerHtml = '';

            // Sort by base Z-index (creation order) for clean output
            elements.sort((a, b) => parseInt(a.dataset.baseZIndex) - parseInt(b.dataset.baseZIndex));

            // Define base CSS for the output elements
            const baseCss = `
.ui-element-wrapper {
    position: absolute;
    box-sizing: border-box;
}
.ui-button {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: default;
    border: none;
    outline: none;
    padding: 0;
    margin: 0;
    /* Optional: Ensure text wraps nicely if using button as a generic container */
    text-align: center; 
}`;

            elements.forEach(el => {
                const button = el.querySelector('.ui-button');
                const isCentered = el.dataset.centered === 'true';
                
                // Collect styles for the wrapper (position and z-index)
                let wrapperStyles = [
                    `position: absolute`,
                    `width: ${el.offsetWidth}px`,
                    `height: ${el.offsetHeight}px`,
                    `z-index: ${el.style.zIndex}`,
                ];
                
                // CRUCIAL: Use responsive centering if toggled ON
                if (isCentered) {
                    wrapperStyles.push(`left: 50%`);
                    wrapperStyles.push(`top: 50%`);
                    wrapperStyles.push(`transform: translate(-50%, -50%)`);
                } else {
                    // FIX: Read the explicit style.left and style.top set by the drag interaction
                    // Fallback to offsetLeft/Top if style isn't explicitly set (e.g. fresh element)
                    const currentLeft = el.style.left || `${el.offsetLeft}px`;
                    const currentTop = el.style.top || `${el.offsetTop}px`;
                    
                    wrapperStyles.push(`left: ${currentLeft}`);
                    wrapperStyles.push(`top: ${currentTop}`);
                }
                
                const wrapperStylesString = wrapperStyles.join('; ');

                // Collect styles for the inner button (design properties)
                const buttonStyles = [
                    button.style.backgroundColor ? `background-color: ${button.style.backgroundColor}` : null,
                    button.style.color ? `color: ${button.style.color}` : null,
                    button.style.fontSize ? `font-size: ${button.style.fontSize}` : null,
                    button.style.borderRadius ? `border-radius: ${button.style.borderRadius}` : null,
                ].filter(s => s).join('; ');

                const content = button.textContent.trim();
                const elementId = el.id.replace('-wrapper', ''); 

                // Use a simple container class for the output
                const buttonHtml = `<button id="${elementId}" class="ui-button" style="${buttonStyles || ''}">${content}</button>`;

                innerHtml += `<div class="ui-element-wrapper" style="${wrapperStylesString}">\n    ${buttonHtml}\n</div>\n\n`;
            });

            // Added basic styling for body to ensure the relative positioning works for the absolute children
            const fullHtml = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generated UI</title>
    <style>
${baseCss.trim()}

/* IMPORTANT: Ensure the body/container is positioned relative or uses min-height: 100vh 
    so the absolute elements have a reference point. */
body {
    margin: 0; 
    padding: 0; 
    min-height: 100vh; /* Make sure there is height to center against */
    position: relative; /* Essential reference for absolute children */
    overflow: hidden; /* Prevent scrollbar if element is exactly 100vh */
}
    </style>
</head>
<body>

${innerHtml.trim()}

</body>
</html>`;

            htmlOutput.value = fullHtml;
        }

        /**
         * Sets the given element as active, updates the UI, and manages Z-index.
         */
        function setActiveElement(element) {
            
            // 1. Clear active state from previous element
            if (activeElement) {
                activeElement.classList.remove('active');
                if (activeElement.dataset.centered !== 'true') {
                    activeElement.style.cursor = 'grab';
                }
                // When deselecting, restore Z-index based on the layer panel
                reorderElements(); 
            }

            // 2. Set new active element
            activeElement = element;

            // 3. Update UI panels
            if (activeElement) {
                activeElement.classList.add('active');
                if (activeElement.dataset.centered !== 'true') {
                    activeElement.style.cursor = 'move';
                }
                
                centerElementToggle.disabled = false; // Enable center toggle
                updateCenterToggleVisual(activeElement.dataset.centered === 'true'); 
                
                updateLayerHighlight();
                updatePropertiesPanel(); // Load properties for the selected element
            } else {
                 centerElementToggle.disabled = true; // Disable center toggle
                 updateCenterToggleVisual(false); // Reset button visual/text
                 updateLayerHighlight();
                 updatePropertiesPanel(); // Hide/Reset properties panel
            }
        }
        
        /**
         * Updates the visual state and text of the center toggle button. (REFINED)
         */
        function updateCenterToggleVisual(isCentered) {
            if (isCentered) {
                // Centered ON: Show green 'Disable' button
                centerElementToggle.classList.remove('bg-yellow-500', 'hover:bg-yellow-600');
                centerElementToggle.classList.add('bg-green-500', 'hover:bg-green-600');
                centerElementToggle.textContent = 'Disable Responsive Centering';
            } else {
                // Centered OFF: Show yellow 'Enable' button
                centerElementToggle.classList.remove('bg-green-500', 'hover:bg-green-600');
                centerElementToggle.classList.add('bg-yellow-500', 'hover:bg-yellow-600');
                centerElementToggle.textContent = 'Enable Responsive Centering';
            }
        }


        /**
         * Creates a new draggable and resizable element.
         */
        function createNewElement(name, initialBgColor, initialTextColor) {
            elementCounter++;
            const elementId = `ui-element-${elementCounter}`;
            const baseZIndex = elementCounter; 

            // 1. Create the wrapper (handles drag/resize/position)
            const wrapper = document.createElement('div');
            wrapper.id = elementId + '-wrapper'; 
            wrapper.classList.add('ui-element-wrapper', 'group');
            wrapper.style.zIndex = baseZIndex; 
            wrapper.dataset.name = name;
            wrapper.dataset.baseZIndex = baseZIndex;
            wrapper.dataset.centered = 'false'; // NEW: Default to not centered
            
            // Initial size and random position
            wrapper.style.width = `150px`;
            wrapper.style.height = `50px`;
            
            const canvasRect = canvas.getBoundingClientRect();
            // Start near center
            const randomX = Math.floor(Math.random() * (canvasRect.width * 0.4)) + canvasRect.width * 0.3; 
            const randomY = Math.floor(Math.random() * (canvasRect.height * 0.4)) + canvasRect.height * 0.3;

            wrapper.style.left = `${Math.max(20, randomX)}px`;
            wrapper.style.top = `${Math.max(20, randomY)}px`;

            wrapper.addEventListener('dblclick', handleDoubleClick);
            // Attach drag/resize handlers
            wrapper.addEventListener('pointerdown', handlePointerDown);


            // 2. Create the inner button (the actual UI component)
            const button = document.createElement('button');
            button.id = elementId; 
            button.classList.add('ui-button'); 
            button.textContent = name;
            button.style.backgroundColor = initialBgColor;
            button.style.color = initialTextColor;
            button.style.fontSize = '16px'; 
            button.style.borderRadius = '8px'; 
            wrapper.appendChild(button);

            // 3. Create resize handles
            const handles = ['tl', 'tr', 'br', 'bl'];
            handles.forEach(pos => {
                const handle = document.createElement('div');
                handle.classList.add('resize-handle', `handle-${pos}`, 'opacity-0', 'group-hover:opacity-100', 'active:opacity-100');
                handle.dataset.handle = pos;
                wrapper.appendChild(handle);
            });

            canvas.appendChild(wrapper);
            
            updateLayers();
            updateHtmlOutput();

            setActiveElement(wrapper);
        }
        
        function createButton() {
             const name = `Action ${elementCounter + 1}`;
             // Default colors: Blue BG, White Text
             createNewElement(name, 'rgb(59, 130, 246)', 'rgb(255, 255, 255)'); 
        }

        function createUIElement() {
            const name = `Generic UI ${elementCounter + 1}`;
            // Default colors: Gray BG, Dark Text
            createNewElement(name, 'rgb(243, 244, 246)', 'rgb(55, 65, 81)');
        }

        /**
         * Handles the double-click event to enable text editing on the button.
         */
        function handleDoubleClick(e) {
            e.stopPropagation(); 
            
            const wrapper = e.currentTarget; 
            const button = wrapper.querySelector('.ui-button');
            const currentText = button.textContent.trim();

            if (isDragging || isResizing) return;
            if (button.querySelector('input')) return;

            // Set active element before showing input
            setActiveElement(wrapper); 

            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentText;
            input.className = 'w-full h-full text-center bg-white/90 font-bold border-2 border-blue-500 rounded-lg p-1 focus:outline-none';
            input.style.boxShadow = '0 0 0 2px rgba(59, 130, 246, 0.5)'; 

            // Copy button's dynamic styles to the input for better visual feedback
            input.style.color = button.style.color;
            input.style.fontSize = button.style.fontSize; 
            
            button.textContent = '';
            button.appendChild(input);

            input.focus();

            const saveChanges = () => {
                const newText = input.value.trim() || "Button"; 
                
                button.textContent = newText;
                
                wrapper.dataset.name = newText; 
                updateLayers(); 
                updateHtmlOutput();
            };

            input.addEventListener('blur', saveChanges);

            input.addEventListener('keypress', (event) => {
                if (event.key === 'Enter') {
                    input.blur(); 
                }
            });
        }


        // --- Properties Panel Management ---

        /**
         * Loads the properties of the active element into the panel inputs.
         */
        function updatePropertiesPanel() {
            if (!activeElement) {
                noSelectionMessage.classList.remove('hidden');
                propertiesControls.classList.add('hidden');
                return;
            }

            const button = activeElement.querySelector('.ui-button');

            noSelectionMessage.classList.add('hidden');
            propertiesControls.classList.remove('hidden');

            // 1. Text
            propText.value = button.textContent.trim();

            // 2. Size
            propWidth.value = Math.round(activeElement.offsetWidth);
            propHeight.value = Math.round(activeElement.offsetHeight);

            // 3. Colors (Convert RGB/CSS names to Hex for color picker)
            propBgColor.value = rgbToHex(button.style.backgroundColor);
            propTextColor.value = rgbToHex(button.style.color);
            
            // 4. Font Size (Extract PX value)
            const currentFontSize = parseFloat(button.style.fontSize.replace('px', '')) || 16;
            propFontSize.value = currentFontSize;
        }

        /**
         * Handles changes from the properties panel inputs.
         */
        function handlePropertyChange(e) {
            if (!activeElement) return;

            const button = activeElement.querySelector('.ui-button');
            const propId = e.target.id;
            const value = e.target.value;

            switch (propId) {
                case 'prop-text':
                    button.textContent = value;
                    activeElement.dataset.name = value;
                    updateLayers(); // Updates name in layer panel
                    break;
                case 'prop-width':
                    activeElement.style.width = `${Math.max(50, parseInt(value) || 50)}px`;
                    break;
                case 'prop-height':
                    activeElement.style.height = `${Math.max(30, parseInt(value) || 30)}px`;
                    break;
                case 'prop-bg-color':
                    button.style.backgroundColor = value; // Hex value works in modern browsers
                    break;
                case 'prop-text-color':
                    button.style.color = value;
                    break;
                case 'prop-font-size':
                    button.style.fontSize = `${Math.max(8, parseInt(value) || 16)}px`;
                    break;
            }

            // If dimensions are changed, we must re-enable drag if centering was disabled
            if (propId === 'prop-width' || propId === 'prop-height') {
                if (activeElement.dataset.centered === 'true') {
                    // Update bounds visually without disabling centering
                    // If centering is active, changing width/height doesn't affect left/top, 
                    // but the element visually resizes from the center point.
                } else {
                    // If not centered, we check if drag position is still inside canvas
                    // This is for robustness but is not strictly necessary for the core fix.
                }
            }
            
            updateHtmlOutput();
        }

        /**
         * Toggles the responsive centering state of the active element. (NEW FUNCTION)
         */
        function toggleResponsiveCentering() {
            if (!activeElement) return;

            const isCentered = activeElement.dataset.centered === 'true';

            if (isCentered) {
                // --- TURN OFF Centering (Disable) ---
                
                // 1. Read the current visual position (using offsetLeft/Top while centered)
                // This gives the element's actual top-left corner position relative to the canvas.
                const currentLeftPx = activeElement.offsetLeft;
                const currentTopPx = activeElement.offsetTop;
                
                // 2. Remove centering dataset and styles
                activeElement.dataset.centered = 'false';
                
                // Crucial: Must remove transform first, before setting fixed position
                activeElement.style.removeProperty('transform'); 
                
                // Remove percentage position properties (they will conflict with pixel position)
                activeElement.style.removeProperty('left'); 
                activeElement.style.removeProperty('top'); 
                
                // 3. Apply the current visual position as fixed pixels to keep it where it is
                activeElement.style.left = `${currentLeftPx}px`;
                activeElement.style.top = `${currentTopPx}px`;
                
                activeElement.style.cursor = 'grab';

            } else {
                // --- TURN ON Centering (Enable) ---
                activeElement.dataset.centered = 'true';
                
                // Apply centering CSS properties
                activeElement.style.left = '50%';
                activeElement.style.top = '50%';
                activeElement.style.transform = 'translate(-50%, -50%)'; 
                activeElement.style.cursor = 'default';
            }

            // Update visual state and output
            updateCenterToggleVisual(activeElement.dataset.centered === 'true');
            activeElement.classList.toggle('active', true); // Keep active state
            updateHtmlOutput();
        }

        // --- Layer Management ---

        /**
         * Finds the list item the dragged element should be placed BEFORE.
         */
        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('li[data-element-id]:not(.opacity-50)')];

            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2; 
                
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: -Infinity }).element; 
        }

        /**
         * Handles when an item is dragged over the layer panel.
         */
        function handleDragOver(e) {
            e.preventDefault(); 
            e.dataTransfer.dropEffect = 'move';

            if (!draggedLi) return;
            
            // Find the element to insert BEFORE
            const afterElement = getDragAfterElement(layerPanel, e.clientY);
            
            if (afterElement == null) {
                layerPanel.appendChild(draggedLi);
            } else {
                layerPanel.insertBefore(draggedLi, afterElement);
            }
        }

        /**
         * Handles when the drag interaction is finished (item is dropped).
         */
        function handleDrop(e) {
            e.preventDefault();
            reorderElements(); 
        }
        
        function handleDragStart(e) {
            draggedLi = e.currentTarget;
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', draggedLi.dataset.elementId);
            setTimeout(() => draggedLi.classList.add('opacity-50', 'border-dashed', 'border-blue-500'), 0); 
        }

        function handleDragEnd(e) {
            if (draggedLi) {
                draggedLi.classList.remove('opacity-50', 'border-dashed', 'border-blue-500');
            }
            draggedLi = null;
            updateLayerHighlight();
        }

        /**
         * Highlights the list item corresponding to the active element.
         */
        function updateLayerHighlight() {
            layerPanel.querySelectorAll('li[data-element-id]').forEach(li => {
                li.classList.remove('bg-blue-100', 'border-blue-500', 'ring-2', 'ring-blue-300');
                if (activeElement && li.dataset.elementId === activeElement.id) {
                    li.classList.add('bg-blue-100', 'border-blue-500', 'ring-2', 'ring-blue-300');
                }
            });
        }

        /**
         * Recalculates and sets the Z-index based on the order in the layer panel.
         */
        function reorderElements() {
            const listItems = Array.from(layerPanel.querySelectorAll('li[data-element-id]'));
            const totalItems = canvas.querySelectorAll('.ui-element-wrapper').length;
            
            // The item at index 0 is at the top layer
            listItems.forEach((li, index) => {
                // Item at index 0 (top) gets Z = totalItems (highest).
                const zIndex = totalItems - index; 
                const wrapperId = li.dataset.elementId; 
                const wrapper = document.getElementById(wrapperId);

                if (wrapper && wrapper !== activeElement) { 
                    wrapper.style.zIndex = zIndex;
                    
                    li.innerHTML = `<span class="font-medium">${li.dataset.name}</span> <span class="text-xs text-gray-400"> (Z: ${zIndex})</span>`;
                } else if (wrapper === activeElement) {
                      // Keep Z-index boosted (1000) for active element only while dragging/resizing, otherwise set actual Z-index
                      if (!isDragging && !isResizing) {
                         wrapper.style.zIndex = zIndex; 
                      }
                      li.innerHTML = `<span class="font-medium">${li.dataset.name}</span> <span class="text-xs text-gray-400"> (Z: ${wrapper.style.zIndex})</span>`;
                }
            });

            if (activeElement) {
                updateLayerHighlight(); 
            }
            
            updateHtmlOutput(); 
        }

        /**
         * Rebuilds the layer panel if needed and attaches all listeners.
         * ***THIS WAS THE INCOMPLETE FUNCTION***
         */
        function updateLayers() {
            const elements = Array.from(canvas.querySelectorAll('.ui-element-wrapper'));

            if (elements.length === 0) {
                layerPanel.innerHTML = '<li class="p-2 text-gray-500 italic">No elements yet.</li>';
                return;
            }

            // Only rebuild the list if the number of elements changed (added or removed)
            const existingLis = layerPanel.querySelectorAll('li[data-element-id]').length;
            if (elements.length !== existingLis) {
                // Rebuild list
                layerPanel.innerHTML = '';
                
                // Sort by current Z-index to reflect the actual order in the canvas
                elements.sort((a, b) => {
                    const zA = parseInt(a.style.zIndex || a.dataset.baseZIndex);
                    const zB = parseInt(b.style.zIndex || b.dataset.baseZIndex);
                    return zB - zA; // Highest Z-index first
                });

                elements.forEach(el => {
                    const li = document.createElement('li');
                    li.classList.add('p-2', 'rounded-md', 'border', 'cursor-grab', 'transition', 'duration-100', 'truncate', 'text-gray-700', 'bg-white', 'border-gray-200');
                    li.dataset.elementId = el.id;
                    li.draggable = true; 
                    li.dataset.name = el.dataset.name;
                    
                    const currentZIndex = el.style.zIndex || el.dataset.baseZIndex;
                    li.innerHTML = `<span class="font-medium">${li.dataset.name}</span> <span class="text-xs text-gray-400"> (Z: ${currentZIndex})</span>`;

                    // Selection listener (important for clicking elements in the panel)
                    li.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const targetEl = document.getElementById(el.id);
                        if (targetEl) {
                            setActiveElement(targetEl);
                        }
                    });
                    
                    // Drag listeners for the layer panel item
                    li.addEventListener('dragstart', handleDragStart);
                    li.addEventListener('dragend', handleDragEnd);
                    
                    layerPanel.appendChild(li);
                });
            }
            // In a real application, you'd also need a way to remove elements
        }


        // --- Drag & Resize Handlers ---

        /**
         * The combined start handler for drag and resize.
         */
        function handlePointerDown(e) {
            e.stopPropagation();
            const target = e.target;
            
            // 1. Get the wrapper element
            const wrapper = target.closest('.ui-element-wrapper');
            if (!wrapper) return;

            // 2. Set the element as active
            setActiveElement(wrapper);
            
            // Prevent drag/resize if element is responsively centered
            if (wrapper.dataset.centered === 'true') {
                 // Clicking on an element will still make it active, but won't start drag/resize
                 return;
            }

            // 3. Check for resize handle interaction
            if (target.classList.contains('resize-handle')) {
                isResizing = true;
                activeHandle = target.dataset.handle;
                wrapper.style.cursor = 'crosshair';

                // Initial dimensions
                startWidth = wrapper.offsetWidth;
                startHeight = wrapper.offsetHeight;
                startLeft = wrapper.offsetLeft;
                startTop = wrapper.offsetTop;
            } else if (wrapper.classList.contains('ui-element-wrapper') && !target.classList.contains('ui-button')) {
                // 4. Check for drag interaction on the wrapper itself (but not the inner button)
                isDragging = true;
                wrapper.style.cursor = 'move';
                
                // Initial position and mouse coordinates
                startX = e.clientX;
                startY = e.clientY;
                startLeft = wrapper.offsetLeft;
                startTop = wrapper.offsetTop;

                // Temporarily boost z-index while dragging
                wrapper.style.zIndex = 1000;
            } else {
                return; // Clicking on the inner button text/content
            }

            // Attach global handlers for drag/resize movement and end
            document.addEventListener('pointermove', handlePointerMove);
            document.addEventListener('pointerup', handlePointerUp);
        }

        /**
         * Handles the movement logic for both drag and resize.
         */
        function handlePointerMove(e) {
            if (!activeElement) return;

            if (isDragging) {
                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;

                let newLeft = startLeft + deltaX;
                let newTop = startTop + deltaY;

                // Get canvas bounds
                const canvasRect = canvas.getBoundingClientRect();
                const wrapperRect = activeElement.getBoundingClientRect();

                // Simple bounds checking (keep element fully inside canvas)
                newLeft = Math.max(0, Math.min(newLeft, canvasRect.width - wrapperRect.width));
                newTop = Math.max(0, Math.min(newTop, canvasRect.height - wrapperRect.height));
                
                activeElement.style.left = `${newLeft}px`;
                activeElement.style.top = `${newTop}px`;
                
                updateHtmlOutput();

            } else if (isResizing) {
                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;

                let newWidth = startWidth;
                let newHeight = startHeight;
                let newLeft = startLeft;
                let newTop = startTop;

                // Resize logic based on handle
                switch (activeHandle) {
                    case 'br': // Bottom-Right
                        newWidth = Math.max(50, startWidth + deltaX);
                        newHeight = Math.max(30, startHeight + deltaY);
                        break;
                    case 'bl': // Bottom-Left
                        newWidth = Math.max(50, startWidth - deltaX);
                        newHeight = Math.max(30, startHeight + deltaY);
                        newLeft = startLeft + (startWidth - newWidth);
                        break;
                    case 'tr': // Top-Right
                        newWidth = Math.max(50, startWidth + deltaX);
                        newHeight = Math.max(30, startHeight - deltaY);
                        newTop = startTop + (startHeight - newHeight);
                        break;
                    case 'tl': // Top-Left
                        newWidth = Math.max(50, startWidth - deltaX);
                        newHeight = Math.max(30, startHeight - deltaY);
                        newLeft = startLeft + (startWidth - newWidth);
                        newTop = startTop + (startHeight - newHeight);
                        break;
                }
                
                activeElement.style.width = `${newWidth}px`;
                activeElement.style.height = `${newHeight}px`;
                activeElement.style.left = `${newLeft}px`;
                activeElement.style.top = `${newTop}px`;

                // Update properties panel after resize
                propWidth.value = Math.round(newWidth);
                propHeight.value = Math.round(newHeight);

                updateHtmlOutput();
            }
        }

        /**
         * The combined end handler for drag and resize.
         */
        function handlePointerUp() {
            if (!activeElement) return;

            // Clean up state
            isDragging = false;
            isResizing = false;
            activeHandle = null;
            activeElement.style.cursor = activeElement.dataset.centered === 'true' ? 'default' : 'move';

            // Restore z-index from the layer panel order
            reorderElements(); 

            // Detach global handlers
            document.removeEventListener('pointermove', handlePointerMove);
            document.removeEventListener('pointerup', handlePointerUp);
        }

        // --- Event Listeners and Initialization (CRUCIAL FIX) ---

        function init() {
            // Get DOM elements
            addButton = document.getElementById('add-button');
            addUI = document.getElementById('add-ui');
            centerElementToggle = document.getElementById('center-element-toggle');
            htmlOutput = document.getElementById('html-output');
            copyHtmlButton = document.getElementById('copy-html-button');
            copyMessage = document.getElementById('copy-message');

            propertiesPanel = document.getElementById('properties-panel');
            noSelectionMessage = document.getElementById('no-selection-message');
            propertiesControls = document.getElementById('properties-controls');

            propText = document.getElementById('prop-text');
            propWidth = document.getElementById('prop-width');
            propHeight = document.getElementById('prop-height');
            propBgColor = document.getElementById('prop-bg-color');
            propTextColor = document.getElementById('prop-text-color');
            propFontSize = document.getElementById('prop-font-size');

            // 1. Toolbox Listeners
            addButton.addEventListener('click', createButton);
            addUI.addEventListener('click', createUIElement);
            centerElementToggle.addEventListener('click', toggleResponsiveCentering);

            // 2. Properties Panel Listeners
            propText.addEventListener('input', handlePropertyChange);
            propWidth.addEventListener('input', handlePropertyChange);
            propHeight.addEventListener('input', handlePropertyChange);
            propBgColor.addEventListener('input', handlePropertyChange);
            propTextColor.addEventListener('input', handlePropertyChange);
            propFontSize.addEventListener('input', handlePropertyChange);

            // 3. Canvas Listeners (for deselecting)
            canvas.addEventListener('click', (e) => {
                 if (e.target === canvas) {
                    setActiveElement(null); // Deselect if clicking on the canvas background
                 }
            });

            // 4. Layer Panel Drag/Drop Listeners
            layerPanel.addEventListener('dragover', handleDragOver);
            layerPanel.addEventListener('drop', handleDrop);
            
            // 5. HTML Output Copy Listener
            copyHtmlButton.addEventListener('click', () => {
                 navigator.clipboard.writeText(htmlOutput.value).then(() => {
                    copyMessage.classList.remove('hidden');
                    setTimeout(() => copyMessage.classList.add('hidden'), 2000);
                 });
            });

            // Add a single starting button for demo purposes
            createButton();
        }

        // Run the initialization function once the DOM is ready
        document.addEventListener('DOMContentLoaded', init);
        
    </script>
</body>
</html>
